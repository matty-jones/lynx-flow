import argparse
import csv
import freud
import os
import signac
import matplotlib.pyplot as plt
import matplotlib.pylab as pl
import pandas as pd
import numpy as np
import scipy.signal as signal
from scipy.ndimage import gaussian_filter

"""
This module determines the first peak of each of the aggregated RDFs (as
generated by RDF_plots.py for all jobs in the workspace), by reading in the RDF
CSVs, and using signal processing to calculate the first peak.
The first peak information is saved in the appropriate
job.document['RDF_first_peak'] as [r, g(r)].
"""


def get_first_peak(project, surface_atom_type=None):
    for job in project:
        print("Detecting peaks in", job.get_id(), "RDF for atom type", surface_atom_type)
        # Skip if this is a parent job
        if ("job_type" in job.sp) and (job.sp.job_type == "parent"):
            continue
        csv_file_location = os.path.join(
            job.ws, "RDFs", "".join(["RDF_C-", surface_atom_type, "_Av.csv"])
        )
        try:
            RDF_Data = pd.read_csv(csv_file_location)
        except FileNotFoundError:
            print("No RDF data found for", job.get_id())
            print("Skipping...")
            continue
        smoothed_RDF = gaussian_filter(RDF_Data["g(r)"], 2.0)

        plt.figure()
        plt.plot(RDF_Data["r"], RDF_Data["g(r)"], c="b")
        plt.plot(RDF_Data["r"], smoothed_RDF, c="r")
        plt.xlabel("r (Ang)")
        plt.ylabel("RDF (Arb. U.)")
        figure_file = csv_file_location.replace(".csv", "_smooth.pdf")
        peaks = signal.argrelextrema(smoothed_RDF, np.greater)
        # Attempt 2: Use scipy.signal to find the peaks automatically based on the
        # non-smoothed RDF
        signal_peaks = signal.find_peaks_cwt(RDF_Data["g(r)"], np.arange(1, 10), noise_perc=20)
        signal_peak_loc = [RDF_Data["r"][i] for i in signal_peaks]
        signal_peak_val = [RDF_Data["g(r)"][i] for i in signal_peaks]
        # Hardcode note: Only peaks with RDF > 0.1 are classified as peaks
        first_two_peaks = []
        for peak_index, peak_val in enumerate(signal_peak_val):
            # Sometimes scipy finds 2 peaks right on top of each other.
            if len(first_two_peaks) > 0:
                prev_loc = first_two_peaks[-1][0]
                new_loc = signal_peak_loc[peak_index]
                # Skip this peak if it's within 1A of the previous one
                if new_loc - prev_loc <= 1.0:
                    continue
            if peak_val > 0.1:
                first_two_peaks.append([signal_peak_loc[peak_index], peak_val])

            if len(first_two_peaks) == 2:
                break
        if len(first_two_peaks) == 1:
            title = "Peaks @ [{:.2f}]".format(first_two_peaks[0][0])
        else:
            title = "Peaks @ [{:.2f}, {:.2f}]".format(*[peak[0] for peak in first_two_peaks])
        plt.title(title)
        try:
            # Update job document with the first peak data
            job.document["".join(["RDF_first_peak_", surface_atom_type])] = first_two_peaks[0]
            # Update job document with the second peak data
            job.document["".join(["RDF_second_peak_", surface_atom_type])] = first_two_peaks[1]
        except IndexError:
            print("Only", len(signal_peaks), "peaks found.")
            print("Check", figure_file, "for more details")
            pass
        plt.scatter([peak[0] for peak in first_two_peaks], [peak[1] for peak in first_two_peaks], c="g", s=100.0, marker="x", zorder=10)
        plt.savefig(figure_file)
        plt.close()


if __name__ == "__main__":
    project = signac.get_project("../")
    surface_atom_types = []
    for stoic_dict_str, _ in project.groupby('stoichiometry'):
        surface_atom_types += list(eval(stoic_dict_str).keys())
    surface_atom_types = list(set(surface_atom_types))
    for atom_type in surface_atom_types:
        get_first_peak(project, surface_atom_type=atom_type)
